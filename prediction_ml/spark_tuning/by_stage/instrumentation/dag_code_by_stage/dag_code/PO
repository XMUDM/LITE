{"0": "     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n", "1": "     val vid2pid = edges.partitionsRDD.mapPartitions(_.flatMap(\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n", "109": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n", "110": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n", "111": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .mapPartitionsWithIndex(\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(new HashPartitioner(numPartitions))\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n", "112": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "137": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "138": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "139": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .mapPartitionsWithIndex(\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(new HashPartitioner(numPartitions))\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n", "14": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "140": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "15": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "16": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(new HashPartitioner(numPartitions))\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .mapPartitionsWithIndex(\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n", "168": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "169": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "17": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n", "170": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .mapPartitionsWithIndex(\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(new HashPartitioner(numPartitions))\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n", "171": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "2": "     val newEdges = edges.withPartitionsRDD(edges.map { e =>\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n", "202": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "203": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "204": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .mapPartitionsWithIndex(\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(new HashPartitioner(numPartitions))\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n", "205": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "239": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "240": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "241": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .mapPartitionsWithIndex(\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(new HashPartitioner(numPartitions))\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n", "242": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "27": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n", "276": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "28": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n", "29": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n           .partitionBy(edges.partitioner.get)\n       .mapPartitionsWithIndex(\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(new HashPartitioner(numPartitions))\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n", "3": "     val vid2pid = edges.partitionsRDD.mapPartitions(_.flatMap(\n       .partitionBy(new HashPartitioner(numPartitions))\n       .mapPartitionsWithIndex(\n", "30": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n", "4": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "43": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n", "44": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n", "45": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n           .partitionBy(edges.partitioner.get)\n       .mapPartitionsWithIndex(\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(new HashPartitioner(numPartitions))\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n", "46": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n", "5": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n", "6": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(new HashPartitioner(numPartitions))\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n       .mapPartitionsWithIndex(\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n", "62": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n", "63": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n", "64": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n           .partitionBy(edges.partitioner.get)\n       .mapPartitionsWithIndex(\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(new HashPartitioner(numPartitions))\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n", "65": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n", "7": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "84": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n", "85": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n", "86": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n           .partitionBy(edges.partitioner.get)\n       .mapPartitionsWithIndex(\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(new HashPartitioner(numPartitions))\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n", "87": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n"}