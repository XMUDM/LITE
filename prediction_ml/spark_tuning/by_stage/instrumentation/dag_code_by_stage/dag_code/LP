{"0": "     val vid2pid = edges.partitionsRDD.mapPartitions(_.flatMap(\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n", "1": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n", "10": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "11": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n           .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n", "12": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "120": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "121": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "122": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n", "123": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "149": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "150": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "151": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n", "152": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "181": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "182": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "183": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n", "184": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "2": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n", "20": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "21": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "216": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "217": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "218": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n", "219": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "22": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n           .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n", "23": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "254": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "255": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "256": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n", "257": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "295": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "296": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "297": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n", "298": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "3": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n           .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n", "339": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "34": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "340": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "341": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n", "342": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "35": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "36": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(edges.partitioner.get)\n", "37": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "386": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "387": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "388": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n", "389": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "4": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "436": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "437": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "438": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n", "439": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "489": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "490": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "491": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n", "492": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "51": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "52": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "53": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n", "54": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "545": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "546": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "547": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n", "548": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "604": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "605": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "606": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n", "607": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "666": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "667": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "668": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n", "669": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "71": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "72": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "73": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n", "731": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "732": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "733": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n", "734": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "74": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "796": "     val clique1Labels = labels.vertices.filter(_._1 < n).map(_._2).collect.toArray\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     deps: Seq[Dependency[_]]) extends RDD[(VertexId, VD)](sc, deps) {\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "858": "     val clique2Labels = labels.vertices.filter(_._1 >= n).map(_._2).collect.toArray\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     deps: Seq[Dependency[_]]) extends RDD[(VertexId, VD)](sc, deps) {\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "9": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "94": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "95": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "96": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val twoCliques = sc.parallelize(clique1 ++ clique2 :+ Edge(0L, n, 1),numPar)\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n", "97": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n"}