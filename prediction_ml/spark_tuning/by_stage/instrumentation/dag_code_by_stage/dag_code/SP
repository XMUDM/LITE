{"0": "     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n", "1": "     val vid2pid = edges.partitionsRDD.mapPartitions(_.flatMap(\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n", "2": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n", "3": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n", "4": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n           .partitionBy(edges.partitioner.get)\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n", "5": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "7": " \tresults.saveAsTextFile(output)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     deps: Seq[Dependency[_]]) extends RDD[(VertexId, VD)](sc, deps) {\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n"}