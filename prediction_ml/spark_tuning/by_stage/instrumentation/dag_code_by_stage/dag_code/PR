{"0": "     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n", "1": "     val vid2pid = edges.partitionsRDD.mapPartitions(_.flatMap(\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n", "14": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n           .partitionBy(edges.partitioner.get)\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n", "15": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n", "16": "     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n           .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n", "2": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n", "25": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n           .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n", "26": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "27": "     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n           .partitionBy(edges.partitioner.get)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n           .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n", "3": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n", "38": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n           .partitionBy(edges.partitioner.get)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n           .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n", "39": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "4": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n", "40": "     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n           .partitionBy(edges.partitioner.get)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n           .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n", "5": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n           .partitionBy(edges.partitioner.get)\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n           .partitionBy(edges.partitioner.get)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n", "53": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n           .partitionBy(edges.partitioner.get)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n           .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n", "54": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "55": "     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n           .partitionBy(edges.partitioner.get)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n           .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n", "6": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "69": "     val rankSum = rankGraph.vertices.values.sum()\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     deps: Seq[Dependency[_]]) extends RDD[(VertexId, VD)](sc, deps) {\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "7": "     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n           .partitionBy(edges.partitioner.get)\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n", "83": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n", "97": "     staticRanks.saveAsTextFile(output);\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     deps: Seq[Dependency[_]]) extends RDD[(VertexId, VD)](sc, deps) {\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n"}