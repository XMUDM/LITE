{"0": "     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n", "1": "     val vid2pid = edges.partitionsRDD.mapPartitions(_.flatMap(\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n", "10": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val vertexPartitions = vPartitioned.zipPartitions(routingTables, preservesPartitioning = true) {\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     deps: Seq[Dependency[_]]) extends RDD[(VertexId, VD)](sc, deps) {\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "2": "     val newEdges = edges.withPartitionsRDD(edges.map { e =>\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n", "3": "     val vid2pid = edges.partitionsRDD.mapPartitions(_.flatMap(\n       .mapPartitionsWithIndex(\n       .partitionBy(new HashPartitioner(numPartitions))\n", "4": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "5": "         .map {\n       .mapPartitionsWithIndex(\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n           .partitionBy(edges.partitioner.get)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(new HashPartitioner(numPartitions))\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n", "6": "     val vid2pid = edges.partitionsRDD.mapPartitions(_.flatMap(\n         .map(e => new Edge(e._1._1, e._1._2, e._2))\n         .reduceByKey(mergeFunc)\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n", "7": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n         .map(e => new Edge(e._1._1, e._1._2, e._2))\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n         .reduceByKey(mergeFunc)\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n", "8": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = partitionsRDD.zipPartitions(routingTables, true) {\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val vertexPartitions = vPartitioned.zipPartitions(routingTables, preservesPartitioning = true) {\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     deps: Seq[Dependency[_]]) extends RDD[(VertexId, VD)](sc, deps) {\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "9": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n         .map(e => new Edge(e._1._1, e._1._2, e._2))\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n           .partitionBy(edges.partitioner.get)\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n         .reduceByKey(mergeFunc)\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n"}