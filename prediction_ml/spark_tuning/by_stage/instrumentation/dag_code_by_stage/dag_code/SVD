{"0": "     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n", "1": "     val newEdges = edges.withPartitionsRDD(edges.map { e =>\n     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n", "10": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "102": "     deps: Seq[Dependency[_]]) extends RDD[(VertexId, VD)](sc, deps) {\n     deps: Seq[Dependency[_]]) extends RDD[(VertexId, VD)](sc, deps) {\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val vertexPartitions = vPartitioned.zipPartitions(routingTables, preservesPartitioning = true) {\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "11": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n        edges=graph.edges.map{ e => {\n       .partitionBy(new HashPartitioner(numPartitions))\n           .partitionBy(edges.partitioner.get)\n     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n       .mapPartitionsWithIndex(\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n", "12": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "17": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "18": "     partitionsRDD.map(_._2.size.toLong).fold(0)(_ + _)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n        edges=graph.edges.map{ e => {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(new HashPartitioner(numPartitions))\n           .partitionBy(edges.partitioner.get)\n     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n       .mapPartitionsWithIndex(\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n", "2": "     val (rs, rc) = edges.map(e => (e.attr, 1L)).fold((0, 0))((a, b) => (a._1 + b._1, a._2 + b._2))\n        edges=graph.edges.map{ e => {\n       .partitionBy(new HashPartitioner(numPartitions))\n     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n       .mapPartitionsWithIndex(\n", "24": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n        edges=graph.edges.map{ e => {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(new HashPartitioner(numPartitions))\n           .partitionBy(edges.partitioner.get)\n     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n       .mapPartitionsWithIndex(\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n", "25": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "32": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "33": "     partitionsRDD.map(_._2.size.toLong).fold(0)(_ + _)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n        edges=graph.edges.map{ e => {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(new HashPartitioner(numPartitions))\n           .partitionBy(edges.partitioner.get)\n     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n       .mapPartitionsWithIndex(\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n", "4": "     val vid2pid = edges.partitionsRDD.mapPartitions(_.flatMap(\n        edges=graph.edges.map{ e => {\n       .partitionBy(new HashPartitioner(numPartitions))\n     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n       .mapPartitionsWithIndex(\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n", "41": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n        edges=graph.edges.map{ e => {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(new HashPartitioner(numPartitions))\n           .partitionBy(edges.partitioner.get)\n     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n       .mapPartitionsWithIndex(\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n", "42": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n", "5": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "51": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n", "52": "     partitionsRDD.map(_._2.size.toLong).fold(0)(_ + _)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n        edges=graph.edges.map{ e => {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(new HashPartitioner(numPartitions))\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n       .mapPartitionsWithIndex(\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n", "62": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n        edges=graph.edges.map{ e => {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(new HashPartitioner(numPartitions))\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n       .mapPartitionsWithIndex(\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n", "63": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n", "7": "     partitionsRDD.map(_._2.size.toLong).fold(0)(_ + _)\n        edges=graph.edges.map{ e => {\n       .partitionBy(new HashPartitioner(numPartitions))\n     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n       .mapPartitionsWithIndex(\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n", "74": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n", "75": "     partitionsRDD.map(_._2.size.toLong).fold(0)(_ + _)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n        edges=graph.edges.map{ e => {\n       .partitionBy(new HashPartitioner(numPartitions))\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n       .mapPartitionsWithIndex(\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n", "87": "     val vid2pid = edges.partitionsRDD.mapPartitions(_.flatMap(\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n        edges=graph.edges.map{ e => {\n       .partitionBy(new HashPartitioner(numPartitions))\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n       .mapPartitionsWithIndex(\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n", "88": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     deps: Seq[Dependency[_]]) extends RDD[(VertexId, VD)](sc, deps) {\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val vertexPartitions = vPartitioned.zipPartitions(routingTables, preservesPartitioning = true) {\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "89": "     replicatedVertexView.edges.partitionsRDD.mapPartitions(_.flatMap {\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n           .partitionBy(edges.partitioner.get)\n        edges=graph.edges.map{ e => {\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(new HashPartitioner(numPartitions))\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n           .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     deps: Seq[Dependency[_]]) extends RDD[Edge[ED]](sc, deps) {\n       .mapPartitionsWithIndex(\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edgePartitions = edges.mapPartitionsWithIndex { (pid, iter) =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n"}