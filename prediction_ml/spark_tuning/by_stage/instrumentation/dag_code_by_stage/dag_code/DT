{"0": "     val numFeatures = input.map(_.features.size).take(1).headOption.getOrElse {\n                 JavaRDD<LabeledPoint> data = tmpdata.map(\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     val retaggedInput = input.retag(classOf[LabeledPoint])\n       instr: Option[Instrumentation],\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n", "1": "     val retaggedInput = input.retag(classOf[LabeledPoint])\n                 JavaRDD<LabeledPoint> data = tmpdata.map(\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n       instr: Option[Instrumentation],\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n", "10": "       input.mapPartitions { points =>\n                 JavaRDD<LabeledPoint> data = tmpdata.map(\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     val retaggedInput = input.retag(classOf[LabeledPoint])\n       instr: Option[Instrumentation],\n     input.map(datum => new BaggedPoint(datum, Array(1.0)))\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     input.map { x =>\n", "11": "     val nodeToBestSplits = partitionAggregates.reduceByKey((a, b) => a.merge(b)).map {\n     val nodeToBestSplits = partitionAggregates.reduceByKey((a, b) => a.merge(b)).map {\n", "12": "       input.mapPartitions { points =>\n                 JavaRDD<LabeledPoint> data = tmpdata.map(\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     val retaggedInput = input.retag(classOf[LabeledPoint])\n       instr: Option[Instrumentation],\n     input.map(datum => new BaggedPoint(datum, Array(1.0)))\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     input.map { x =>\n", "13": "     val nodeToBestSplits = partitionAggregates.reduceByKey((a, b) => a.merge(b)).map {\n     val nodeToBestSplits = partitionAggregates.reduceByKey((a, b) => a.merge(b)).map {\n", "14": "       input.mapPartitions { points =>\n                 JavaRDD<LabeledPoint> data = tmpdata.map(\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     val retaggedInput = input.retag(classOf[LabeledPoint])\n       instr: Option[Instrumentation],\n     input.map(datum => new BaggedPoint(datum, Array(1.0)))\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     input.map { x =>\n", "15": "     val nodeToBestSplits = partitionAggregates.reduceByKey((a, b) => a.merge(b)).map {\n     val nodeToBestSplits = partitionAggregates.reduceByKey((a, b) => a.merge(b)).map {\n", "16": "       input.mapPartitions { points =>\n                 JavaRDD<LabeledPoint> data = tmpdata.map(\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     val retaggedInput = input.retag(classOf[LabeledPoint])\n       instr: Option[Instrumentation],\n     input.map(datum => new BaggedPoint(datum, Array(1.0)))\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     input.map { x =>\n", "17": "     val nodeToBestSplits = partitionAggregates.reduceByKey((a, b) => a.merge(b)).map {\n     val nodeToBestSplits = partitionAggregates.reduceByKey((a, b) => a.merge(b)).map {\n", "18": "       input.mapPartitions { points =>\n                 JavaRDD<LabeledPoint> data = tmpdata.map(\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     val retaggedInput = input.retag(classOf[LabeledPoint])\n       instr: Option[Instrumentation],\n     input.map(datum => new BaggedPoint(datum, Array(1.0)))\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     input.map { x =>\n", "19": "     val nodeToBestSplits = partitionAggregates.reduceByKey((a, b) => a.merge(b)).map {\n     val nodeToBestSplits = partitionAggregates.reduceByKey((a, b) => a.merge(b)).map {\n", "2": "         .flatMap { point =>\n                 JavaRDD<LabeledPoint> data = tmpdata.map(\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     val retaggedInput = input.retag(classOf[LabeledPoint])\n       instr: Option[Instrumentation],\n       input.sample(withReplacement = false, fraction, new XORShiftRandom(seed).nextInt())\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n", "20": "       input.mapPartitions { points =>\n                 JavaRDD<LabeledPoint> data = tmpdata.map(\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     val retaggedInput = input.retag(classOf[LabeledPoint])\n       instr: Option[Instrumentation],\n     input.map(datum => new BaggedPoint(datum, Array(1.0)))\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     input.map { x =>\n", "21": "     val nodeToBestSplits = partitionAggregates.reduceByKey((a, b) => a.merge(b)).map {\n     val nodeToBestSplits = partitionAggregates.reduceByKey((a, b) => a.merge(b)).map {\n", "22": "       input.mapPartitions { points =>\n                 JavaRDD<LabeledPoint> data = tmpdata.map(\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     val retaggedInput = input.retag(classOf[LabeledPoint])\n       instr: Option[Instrumentation],\n     input.map(datum => new BaggedPoint(datum, Array(1.0)))\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     input.map { x =>\n", "23": "     val nodeToBestSplits = partitionAggregates.reduceByKey((a, b) => a.merge(b)).map {\n     val nodeToBestSplits = partitionAggregates.reduceByKey((a, b) => a.merge(b)).map {\n", "24": "                 1.0 * predictionAndLabel.filter(new Function<Tuple2<Double, Double>, Boolean>() {\n                 JavaRDD<LabeledPoint> data = tmpdata.map(\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n                 data.mapToPair(new PairFunction<LabeledPoint, Double, Double>() {\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n", "25": "                 JavaRDD<LabeledPoint> data = tmpdata.map(\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n", "3": "         .map { case (idx, samples) =>\n         }.groupByKey(numPartitions)\n", "4": "       input.mapPartitions { points =>\n                 JavaRDD<LabeledPoint> data = tmpdata.map(\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     val retaggedInput = input.retag(classOf[LabeledPoint])\n       instr: Option[Instrumentation],\n     input.map(datum => new BaggedPoint(datum, Array(1.0)))\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     input.map { x =>\n", "5": "     val nodeToBestSplits = partitionAggregates.reduceByKey((a, b) => a.merge(b)).map {\n     val nodeToBestSplits = partitionAggregates.reduceByKey((a, b) => a.merge(b)).map {\n", "6": "       input.mapPartitions { points =>\n                 JavaRDD<LabeledPoint> data = tmpdata.map(\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     val retaggedInput = input.retag(classOf[LabeledPoint])\n       instr: Option[Instrumentation],\n     input.map(datum => new BaggedPoint(datum, Array(1.0)))\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     input.map { x =>\n", "7": "     val nodeToBestSplits = partitionAggregates.reduceByKey((a, b) => a.merge(b)).map {\n     val nodeToBestSplits = partitionAggregates.reduceByKey((a, b) => a.merge(b)).map {\n", "8": "       input.mapPartitions { points =>\n                 JavaRDD<LabeledPoint> data = tmpdata.map(\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     val retaggedInput = input.retag(classOf[LabeledPoint])\n       instr: Option[Instrumentation],\n     input.map(datum => new BaggedPoint(datum, Array(1.0)))\n                 JavaRDD<String> tmpdata = sc.textFile(input);\n     input.map { x =>\n", "9": "     val nodeToBestSplits = partitionAggregates.reduceByKey((a, b) => a.merge(b)).map {\n     val nodeToBestSplits = partitionAggregates.reduceByKey((a, b) => a.merge(b)).map {\n"}