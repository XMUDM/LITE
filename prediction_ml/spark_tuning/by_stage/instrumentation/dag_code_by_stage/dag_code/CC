{"0": "     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n", "1": "     val vid2pid = edges.partitionsRDD.mapPartitions(_.flatMap(\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n", "10": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "11": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "12": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n           .partitionBy(edges.partitioner.get)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n", "13": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "2": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "21": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "22": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "23": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       .partitionBy(edges.partitioner.get)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n           .partitionBy(edges.partitioner.get)\n", "24": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "3": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "35": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexAttributes(shipSrc, shipDst)))\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n", "36": "     partitionsRDD.mapPartitions(_.flatMap(_.shipVertexIds()))\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "37": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedActives) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n       .partitionBy(edges.partitioner.get)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       .partitionBy(edges.partitioner.get)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n       .partitionBy(edges.partitioner.get)\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n           .partitionBy(edges.partitioner.get)\n", "38": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "4": "     val preAgg = view.edges.partitionsRDD.mapPartitions(_.flatMap {\n       .partitionBy(edges.partitioner.get)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n       val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     val newEdges = edges.withPartitionsRDD(edges.partitionsRDD.zipPartitions(shippedVerts) {\n     this.withPartitionsRDD[ED2, VD2](partitionsRDD.mapPartitions({ iter =>\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n     val edges = lines.mapPartitionsWithIndex { (pid, iter) =>\n           .partitionBy(edges.partitioner.get)\n         sc.textFile(path, numEdgePartitions).coalesce(numEdgePartitions)\n", "49": " \tres.saveAsTextFile(output);\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     deps: Seq[Dependency[_]]) extends RDD[(VertexId, VD)](sc, deps) {\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     ) { (thisIter, otherIter) =>\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     ) { (thisIter, otherIter) =>\n     ) { (thisIter, otherIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n", "5": "     partitionsRDD.map(_.size.toLong).fold(0)(_ + _)\n     val vertexPartitions = routingTables.mapPartitions({ routingTableIter =>\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n     val newPartitionsRDD = partitionsRDD.mapPartitions(_.map(f), preservesPartitioning = true)\n     val shuffled = messages.partitionBy(this.partitioner.get)\n     val parts = partitionsRDD.zipPartitions(shuffled, true) { (thisIter, msgIter) =>\n     vid2pid.partitionBy(vertexPartitioner).mapPartitions(\n"}