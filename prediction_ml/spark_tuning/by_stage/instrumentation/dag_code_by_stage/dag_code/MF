{"0": "   ", "1": "     SchemaUtils.appendColumn(schema, $(predictionCol), FloatType)\n   ", "10": "     inBlocks.map { case (srcBlockId, inBlock) =>\n       .mapValues { iter =>\n     }.groupByKey(new ALSPartitioner(srcPart.numPartitions))\n", "12": "     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n     val outBlocks = inBlocks.mapValues { case InBlock(srcIds, dstPtrs, dstEncodedIndices, _) =>\n     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n       .mapValues { iter =>\n     }.groupByKey(new ALSPartitioner(srcPart.numPartitions))\n     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n", "13": "     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n     val merged = srcOut.groupByKey(new ALSPartitioner(dstInBlocks.partitions.length))\n     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n     dstInBlocks.join(merged).mapValues {\n     dstInBlocks.join(merged).mapValues {\n     dstInBlocks.join(merged).mapValues {\n     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n     val outBlocks = inBlocks.mapValues { case InBlock(srcIds, dstPtrs, dstEncodedIndices, _) =>\n     }.groupByKey(new ALSPartitioner(srcPart.numPartitions))\n       .mapValues { iter =>\n     dstInBlocks.join(merged).mapValues {\n     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n", "14": "     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n     val outBlocks = inBlocks.mapValues { case InBlock(srcIds, dstPtrs, dstEncodedIndices, _) =>\n     dstInBlocks.join(merged).mapValues {\n     val merged = srcOut.groupByKey(new ALSPartitioner(dstInBlocks.partitions.length))\n     dstInBlocks.join(merged).mapValues {\n     dstInBlocks.join(merged).mapValues {\n       .mapValues { iter =>\n     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n     }.groupByKey(new ALSPartitioner(srcPart.numPartitions))\n     dstInBlocks.join(merged).mapValues {\n", "15": "     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n     dstInBlocks.join(merged).mapValues {\n     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n     dstInBlocks.join(merged).mapValues {\n     dstInBlocks.join(merged).mapValues {\n     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n     val merged = srcOut.groupByKey(new ALSPartitioner(dstInBlocks.partitions.length))\n     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n     val outBlocks = inBlocks.mapValues { case InBlock(srcIds, dstPtrs, dstEncodedIndices, _) =>\n     dstInBlocks.join(merged).mapValues {\n     }.groupByKey(new ALSPartitioner(srcPart.numPartitions))\n       .mapValues { iter =>\n", "16": "     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n     dstInBlocks.join(merged).mapValues {\n     val outBlocks = inBlocks.mapValues { case InBlock(srcIds, dstPtrs, dstEncodedIndices, _) =>\n     val merged = srcOut.groupByKey(new ALSPartitioner(dstInBlocks.partitions.length))\n     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n     dstInBlocks.join(merged).mapValues {\n       .mapValues { iter =>\n     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n     }.groupByKey(new ALSPartitioner(srcPart.numPartitions))\n     dstInBlocks.join(merged).mapValues {\n     dstInBlocks.join(merged).mapValues {\n", "17": "     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n     dstInBlocks.join(merged).mapValues {\n     dstInBlocks.join(merged).mapValues {\n     val merged = srcOut.groupByKey(new ALSPartitioner(dstInBlocks.partitions.length))\n     dstInBlocks.join(merged).mapValues {\n     val outBlocks = inBlocks.mapValues { case InBlock(srcIds, dstPtrs, dstEncodedIndices, _) =>\n     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n     }.groupByKey(new ALSPartitioner(srcPart.numPartitions))\n       .mapValues { iter =>\n     dstInBlocks.join(merged).mapValues {\n     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n     val srcOut = srcOutBlocks.join(srcFactorBlocks).flatMap {\n", "18": "     @transient val userFactors: DataFrame,\n     dstInBlocks.join(merged).mapValues {\n     dstInBlocks.join(merged).mapValues {\n       .join(userFactors)\n       .mapPartitions({ items =>\n       .mapValues(_.srcIds)\n       .join(userFactors)\n     dstInBlocks.join(merged).mapValues {\n       .mapValues { iter =>\n     dstInBlocks.join(merged).mapValues {\n     }.groupByKey(new ALSPartitioner(srcPart.numPartitions))\n       .join(userFactors)\n     val merged = srcOut.groupByKey(new ALSPartitioner(dstInBlocks.partitions.length))\n", "2": "     ratings.mapPartitions { iter =>\n      SchemaUtils.appendColumn(schema, $(predictionCol), FloatType)\n  ", "28": "   /** @group setParam */\n     dstInBlocks.join(merged).mapValues {\n     dstInBlocks.join(merged).mapValues {\n       .join(itemFactors)\n     val merged = srcOut.groupByKey(new ALSPartitioner(dstInBlocks.partitions.length))\n       .join(itemFactors)\n       .mapValues(_.srcIds)\n     dstInBlocks.join(merged).mapValues {\n       .join(itemFactors)\n       .mapPartitions({ items =>\n       .mapValues { iter =>\n     }.groupByKey(new ALSPartitioner(srcPart.numPartitions))\n     dstInBlocks.join(merged).mapValues {\n", "3": "     val inBlocks = ratingBlocks.map {\n     }.groupByKey().mapValues { blocks =>\n     }.groupByKey().mapValues { blocks =>\n", "39": "     @transient val userFactors: DataFrame,\n     dstInBlocks.join(merged).mapValues {\n     dstInBlocks.join(merged).mapValues {\n       .join(userFactors)\n       .mapPartitions({ items =>\n       .mapValues(_.srcIds)\n       .join(userFactors)\n     dstInBlocks.join(merged).mapValues {\n       .mapValues { iter =>\n     dstInBlocks.join(merged).mapValues {\n     }.groupByKey(new ALSPartitioner(srcPart.numPartitions))\n       .join(userFactors)\n     val merged = srcOut.groupByKey(new ALSPartitioner(dstInBlocks.partitions.length))\n", "4": "     val outBlocks = inBlocks.mapValues { case InBlock(srcIds, dstPtrs, dstEncodedIndices, _) =>\n       .mapValues { iter =>\n     }.groupByKey(new ALSPartitioner(srcPart.numPartitions))\n", "49": "   /** @group setParam */\n     dstInBlocks.join(merged).mapValues {\n     dstInBlocks.join(merged).mapValues {\n       .join(itemFactors)\n     val merged = srcOut.groupByKey(new ALSPartitioner(dstInBlocks.partitions.length))\n       .join(itemFactors)\n       .mapValues(_.srcIds)\n     dstInBlocks.join(merged).mapValues {\n       .join(itemFactors)\n       .mapPartitions({ items =>\n       .mapValues { iter =>\n     }.groupByKey(new ALSPartitioner(srcPart.numPartitions))\n     dstInBlocks.join(merged).mapValues {\n", "50": "    ", "6": "     val inBlocks = ratingBlocks.map {\n     }.groupByKey().mapValues { blocks =>\n     }.groupByKey().mapValues { blocks =>\n     val swappedBlockRatings = blockRatings.map {\n", "60": "       val products = productFeatures.join(usersProducts.map(_.swap)).map {\n    ", "62": "       val products = productFeatures.join(usersProducts.map(_.swap)).map {\n     dstInBlocks.join(merged).mapValues {\n   /** @group setParam */\n     dstInBlocks.join(merged).mapValues {\n       .join(itemFactors)\n     }.groupByKey(new ALSPartitioner(srcPart.numPartitions))\n       .mapValues { iter =>\n       val products = productFeatures.join(usersProducts.map(_.swap)).map {\n     dstInBlocks.join(merged).mapValues {\n       .join(itemFactors)\n     val merged = srcOut.groupByKey(new ALSPartitioner(dstInBlocks.partitions.length))\n       .join(itemFactors)\n       val products = productFeatures.join(usersProducts.map(_.swap)).map {\n       .mapValues(_.srcIds)\n       val products = productFeatures.join(usersProducts.map(_.swap)).map {\n       .mapPartitions({ items =>\n     dstInBlocks.join(merged).mapValues {\n", "63": "      dstInBlocks.join(merged).mapValues {\n     dstInBlocks.join(merged).mapValues {\n       .join(userFactors)\n       products.join(userFeatures).map {\n       .join(userFactors)\n     dstInBlocks.join(merged).mapValues {\n       .join(userFactors)\n     val merged = srcOut.groupByKey(new ALSPartitioner(dstInBlocks.partitions.length))\n       products.join(userFeatures).map {\n       .mapPartitions({ items =>\n       .mapValues(_.srcIds)\n     @transient val userFactors: DataFrame,\n       .mapValues { iter =>\n     dstInBlocks.join(merged).mapValues {\n       products.join(userFeatures).map {\n     }.groupByKey(new ALSPartitioner(srcPart.numPartitions))\n       products.join(userFeatures).map {\n", "64": "    ", "65": "      ", "7": "     val outBlocks = inBlocks.mapValues { case InBlock(srcIds, dstPtrs, dstEncodedIndices, _) =>\n     }.groupByKey(new ALSPartitioner(srcPart.numPartitions))\n       .mapValues { iter =>\n"}